/*
https://stepik.org/course/124803/

Преобразование типов
                https://stepik.org/lesson/824555/step/1?unit=828020

                    Порядок расширения задается цепочкой:
                        byte -> short-> int-> long -> float -> double.

                            int i = 10;
                            long m = i; //допустимо, int расширяется до long
                            //short k = i; //ошибка



                    Переменной типа char нельзя присвоить значение переменной числового типа, но можно присвоить числовой литерал.
                            int a = 65;
                            char c;
                            //c = a; //ошибка
                            c = 65;


                    А вот переменной числового типа (кроме byte и short) можно присвоить значение переменной типа char (в целевую переменную копируется код символа).
                            int k;
                            char sim = 'A';
                            k = sim;
                            //short j = sim; //ошибка



                    При неявном преобразовании типов int или long к типам float и double может произойти потеря точности. Это иллюстрирует простой пример:
                            int big = 1234567890;
                            float f = big;
                            System.out.printf("%f", f);    //1234567936.000000.



                    Явное преобразование типов (целевой тип) выражение
                            int i = 98;
                            char ch = (char)i;


                    При явном преобразовании тоже происходит потеря точности - переполнение (overflow) или потеря значений (underflow).
                            //Пример overflow (преобразуем в меньший тип в цепочке):
                                    short maxValue = 256;
                                    byte bb = (byte) maxValue;
                                    System.out.println(bb);          //0 , так как преобразуем в меньший тип в цепочке



                            //Примеры underflow (берем вещественное число, преобразуем в целое, теряем друбную часть):
                                    float f3 = 3.64f;
                                    int i3 = (int) f3; // дробная часть отбрасывается
                                    System.out.println(i3);                                     //  3 ,  вещественное число, преобразуем в целое, теряем друбную часть


                                    double d1 = 0.3333333333333333;
                                    float f1 = (float) d1;
                                    System.out.println(f1);                                     //: 0.33333334 , потеря чисел после точки начиная с 8 знака





                    Преобразование типов в сложном выражении справа от знака присваивания.
                    Используется правило повышения типов (promotion rules).
                      -  Сначала все значения типа char, byte и short повышаются до типа int.
                      -  А затем выполняется повышение типа выражения до типа с наиболее широким диапазоном согласно цепочке  int-> long -> float -> double.



                    Использование этих правил приводит к неожиданным результатам
                            byte b = 10;
                            int i = b * b;      //приведение не требуется, результат уже повышен до int
                            b = b  * b;         //будет ошибка, слева тип byte, справа тип стал int (повысился до int)
                            b = (byte)(b * b);  // поэтому требуется приведение типов


                            аналогично (нужно явно приводить тип)
                            char ch1 = 'a', ch2 = 'b';
                            ch1 = (char)(ch1 + ch2);

















 */
package a1_Osnova;



public class a2_Privedenie_tipov {
}
