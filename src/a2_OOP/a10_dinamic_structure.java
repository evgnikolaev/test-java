/*

https://stepik.org/lesson/1098422/step/2?unit=1109294

Динамичекие структуры данных:
    - стек, очередь и дек
    - разрешены только операции вставки и удаления первого и/или последнего элемента.


Стек

        Стек (stack) – это упорядоченный набор элементов, для которого добавление новых и удаление существующих элементов
                        допустимо только с одного конца, который называется вершиной стека.
                        Стек также называют структурой типа LIFO (Last In – First Out) – "последним пришел, первым ушел".

        В современных компьютерах стек используется для размещения локальных переменных, параметров функции и адреса возврата из функции.


        Для стека разрешены следующие операции:
            - Добавление элемента в вершину стека (push);
            - Извлечение элемента из вершины стека (pop);
            - Чтение элемента из вершины стека без его удаления (peek).
            - Просмотр (печать) стека от вершины ко дну;
            - Очистка стека (удаление всех элементов).





Очередь

        Очередь (queue) – это упорядоченный набор элементов, в котором добавление новых элементов допустимо
        с одного конца (он называется концом очереди), а удаление существующих элементов – только с другого конца,
        который называется началом очереди.

        Хорошо знакомой моделью является очередь в магазине.
        Очередь называют структурой типа FIFO (First In – First Out) – "первым пришел, первым ушел".


        Для очереди создадим следующие операции:
            - Добавление элемента в конец очереди (add);
            - Извлечение элемента из начала очереди (poll);
            - Чтение элемента из начала очереди без его удаления (peek).
            - Просмотр (печать) очереди от  начала к концу;
            - Очистка очереди (удаление всех элементов).





Дек

        Дек (deque) - это упорядоченный набор элементов, в котором добавление новых и удаление существующих
        элементов допустимо с любого конца.

        Для дека разрешены операции:
            - Добавление элемента слева (addFirst) ;
            - Добавление элемента справа (addLast);
            - Извлечение элемента слева (pollFirst);
            - Извлечение элемента справа (pollLast);
            - Чтение элемента слева без удаления (peekFirst);
            - Чтение элемента справа без удаления (peekLast);
            - Просмотр (печать) дека слева направо;
            - Очистка дека (удаление всех элементов).

*/
package a2_OOP;

import java.util.InputMismatchException;
import java.util.Scanner;


// пример реализации очереди
class a10_dinamic_structure {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        Queue queue = new Queue(scan.nextInt()); //вводим размер буфера и создаем очередь

        int choice;
        char sim;
        try {
            while (true) {
                choice = scan.nextInt(); //вводим выбор пользователя
                try {
                    switch (choice) {
                        case 1:
                            sim = scan.next().charAt(0); //чтение символа
                            queue.add(sim);
                            break;
                        case 2:
                            sim = queue.poll();
                            System.out.println("Извлечено: " + sim);
                            break;
                        case 3:
                            queue.print();
                            break;
                        case 4:
                            queue.clear();
                            break;
                        default:
                            return; //окончание программы
                    }
                } catch (QueueException ex) {
                    System.out.println(ex.getMessage());
                }
            }
        } catch (InputMismatchException ex) {
            System.out.println("Некорректный ввод данных");
        }
    }
}



class Queue {
    private char[] array; //ссылка на внутренний массив для хранения очереди
    private int tail; //индекс последнего элемента. индекс первого элемента - 0

    public Queue(int n) { //в конструктор передаем размер внутреннего массива =размер буфера
        array = new char[n]; //выделение памяти под массив
        tail = -1; //пока нет элементов
    }

    public void add(char c) throws QueueException { //занести символ в конец очереди;
        if (tail == array.length - 1) throw new QueueException("Буфер заполнен!");
        array[++tail] = c; //запись в конец очереди
    }

    public char poll() throws QueueException { // извлечь символ из начала очереди;
        if (tail == -1) throw new QueueException("Извлечение из пустой очереди!");
        char tmp = array[0]; //сохраняем копию  первого элемента
        //сдвигаем весь массив на один элемент влево
        for (int i = 0; i < tail; i++) {
            array[i] = array[i + 1];
        }
        tail--;
        return tmp;
    }

    public void print() { //распечатать очередь от начала к концу;
        for (int i = 0; i <= tail; i++) {
            System.out.print(array[i] + " ");
        }
        System.out.println();
    }

    public void clear() { // очистка очереди
        tail = -1;
    }
}



class QueueException extends Exception {
    public QueueException() {
    }

    public QueueException(String message) {
        super(message);
    }
}